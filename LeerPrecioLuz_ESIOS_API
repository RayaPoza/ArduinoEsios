#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
#include <RTClib.h>

//   Placa WeMos D1
//   Tiny RTC DS1307 I2C
//   LCD Crystal PCF8574A
//   Consulta GET ejemplo:  indicators/1013?start_date=09-06-2019T00%3A00&end_date=09-06-2019T23%3A00





#include <ArduinoJson.h>
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include "config.h" // donde estan los datos sensibles
// WiFi Parameters
const char* ssid = SSID_NAME;
const char* password = WIFI_PASSWORD;
HTTPClient httpClient;  //Object of class HTTPClient

//API
const String SERVER_ESIOS = "https://api.esios.ree.es/";
const String TOKEN = TOKEN_API;
const char* FINGERPRINT=FINGERPRINT_API;

const String TYPE = "indicators";
const String PEAJE_DEFAULT = "1013";
//LCD
const int NUM_CHAR = 20;
const int NUM_LINES = 4;
LiquidCrystal_I2C lcd(0x3F, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);  // Set the LCD I2C address

//TINY RTC
RTC_DS1307 rtc;
int analogBAT = A0; //leer estado de la bateria ADC


void setup() {

  Serial.begin(115200);
  //Wire.begin(); // Inicia el puerto I2C
  rtc.begin();
  //rtc.adjust(DateTime(__DATE__, __TIME__)); // Establece la fecha y hora (Comentar una vez establecida la hora)

  pinMode(analogBAT, OUTPUT);
  
  lcd.begin(NUM_CHAR,NUM_LINES);         // initialize the lcd for 20 chars 4 lines and turn on backlight
  lcd.backlight(); // backlight on 

  String url = SERVER_ESIOS + TYPE + '/' + PEAJE_DEFAULT + "?start_date=" + "11-06-2019" + "T00";
  Serial.println(url);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    yield();        
    Serial.println("Connecting...");
    delay(5000);
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Connected");
    httpClient.begin(url,FINGERPRINT);
    httpClient.addHeader("Host", "api.esios.ree.es");
    httpClient.addHeader("Authorization", "Token token="+TOKEN);    
    httpClient.addHeader("Accept", "application/json; application/vnd.esios-api-v1+json");
    httpClient.addHeader("Content-Type", "application/json");
    //httpClient.addHeader("Cookie", "");
    int httpCodeResponse = httpClient.GET();
    Serial.println("HTTPCODE: " + httpCodeResponse);  
       
    if(!httpCodeResponse>0){
      String error = httpClient.errorToString(httpCodeResponse);
       Serial.println("Error code response: "+ error);
    }
    
       
    //Check the returning code
    if (httpCodeResponse >0) {           
      // Get the request response payload      
      String payload = httpClient.getString();
      //Serial.println("PAYLOAD:");
      //Serial.println(payload);      
      // Inside the brackets is the capacity of the memory pool in bytes.
      // Don't forget to change this value to match your JSON document.
      // Use arduinojson.org/v6/assistant to compute the capacity.
      DynamicJsonDocument doc(13000) ;
      // Deserialize the JSON document
      yield();
      DeserializationError error = deserializeJson(doc, payload);
     // Test if parsing succeeds.
      if (error) {
        Serial.print("deserializeJson() failed: ");
        Serial.println(error.c_str());
        return;
      }
      const char* des = doc["indicator"]["short_name"];
      Serial.println(des);      
      JsonArray values = doc["indicator"]["values"];
      for (JsonObject val : values) {
        Serial.print(" Fecha ");
        Serial.print(val["datetime"].as<char *>());
        Serial.print(", valor: ");
        Serial.print(val["value"].as<long>()); 
        Serial.println("");     
      }
    }    
    httpClient.end();   //Close connection
    Serial.println("CLOSE CONNECTION");
  }
}

void loop() {
  //int val = analogRead(analogBAT);  // read the input pin
  //Serial.println(val);
  //delay(1000);
}
